// This file is @generated by prost-build.
/// Common types
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Bucket {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub signature: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct Key {
    #[prost(bytes = "vec", tag = "1")]
    pub data: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueWriteRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub ct: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "2")]
    pub ct_ntf: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "3")]
    pub f: ::prost::alloc::vec::Vec<u8>,
    #[prost(bytes = "vec", tag = "4")]
    pub f_ntf: ::prost::alloc::vec::Vec<u8>,
    #[prost(message, optional, tag = "5")]
    pub k_renc_t: ::core::option::Option<Key>,
    #[prost(bytes = "vec", tag = "6")]
    pub c_s: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct QueueWriteResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchWriteResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchInitRequest {
    #[prost(uint32, tag = "1")]
    pub num_writes: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct BatchInitResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub index: ::prost::alloc::vec::Vec<u8>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadResponse {
    #[prost(message, repeated, tag = "1")]
    pub buckets: ::prost::alloc::vec::Vec<Bucket>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteRequest {
    #[prost(message, repeated, tag = "1")]
    pub pathset: ::prost::alloc::vec::Vec<Bucket>,
    #[prost(message, optional, tag = "2")]
    pub prf_key: ::core::option::Option<Key>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct WriteResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkWriteRequest {
    #[prost(message, repeated, tag = "1")]
    pub buckets: ::prost::alloc::vec::Vec<Bucket>,
    #[prost(uint32, repeated, tag = "2")]
    pub pathset_indices: ::prost::alloc::vec::Vec<u32>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkWriteResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPrfKeysRequest {
    #[prost(uint32, tag = "1")]
    pub num_clients: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetPrfKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub keys: ::prost::alloc::vec::Vec<Key>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadNotifsRequest {
    #[prost(map = "uint64, message", tag = "1")]
    pub notifications: ::std::collections::HashMap<u64, read_notifs_request::Indices>,
}
/// Nested message and enum types in `ReadNotifsRequest`.
pub mod read_notifs_request {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Indices {
        #[prost(bytes = "vec", repeated, tag = "1")]
        pub index: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    }
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ReadNotifsResponse {
    #[prost(map = "uint64, message", tag = "1")]
    pub epoch_buckets: ::std::collections::HashMap<u64, read_notifs_response::Buckets>,
}
/// Nested message and enum types in `ReadNotifsResponse`.
pub mod read_notifs_response {
    #[allow(clippy::derive_partial_eq_without_eq)]
    #[derive(Clone, PartialEq, ::prost::Message)]
    pub struct Buckets {
        #[prost(message, repeated, tag = "1")]
        pub bucket: ::prost::alloc::vec::Vec<super::Bucket>,
    }
}
/// New messages for separate notification chunking and adding PRF key:
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifChunkRequest {
    #[prost(bytes = "vec", tag = "1")]
    pub raw_notification_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub num_buckets: u32,
    /// Starting index for this chunk's notifications
    #[prost(uint32, tag = "3")]
    pub start_index: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct NotifChunkResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddPrfKeyRequest {
    #[prost(message, optional, tag = "1")]
    pub prf_key: ::core::option::Option<Key>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct AddPrfKeyResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
/// New method for getting MegaClient writes
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMegaClientWritesRequest {
    #[prost(uint32, tag = "1")]
    pub chunk_index: u32,
    #[prost(uint32, tag = "2")]
    pub chunk_size: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetMegaClientWritesResponse {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub cts: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub ct_ntfs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "3")]
    pub fs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "4")]
    pub f_ntfs: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(message, repeated, tag = "5")]
    pub k_renc_ts: ::prost::alloc::vec::Vec<Key>,
    #[prost(bytes = "vec", repeated, tag = "6")]
    pub c_ss: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bool, tag = "7")]
    pub is_last_chunk: bool,
}
/// Replace SendIndices with ChunkProcessRead
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkProcessReadRequest {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub notification_indices: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
    #[prost(bytes = "vec", repeated, tag = "2")]
    pub read_indices: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkProcessReadResponse {
    #[prost(message, repeated, tag = "1")]
    pub read_buckets: ::prost::alloc::vec::Vec<Bucket>,
    #[prost(message, repeated, tag = "2")]
    pub notification_buckets: ::prost::alloc::vec::Vec<Bucket>,
    #[prost(uint32, tag = "3")]
    pub processing_time_ms: u32,
}
/// New separate messages for read and notification processing
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkProcessReadIndicesRequest {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub read_indices: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkProcessReadIndicesResponse {
    #[prost(message, repeated, tag = "1")]
    pub read_buckets: ::prost::alloc::vec::Vec<Bucket>,
    #[prost(uint32, tag = "2")]
    pub processing_time_ms: u32,
    /// Indicates if this is the last chunk
    #[prost(bool, tag = "3")]
    pub is_last_chunk: bool,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkProcessNotifIndicesRequest {
    #[prost(bytes = "vec", repeated, tag = "1")]
    pub notification_indices: ::prost::alloc::vec::Vec<::prost::alloc::vec::Vec<u8>>,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct ChunkProcessNotifIndicesResponse {
    /// Replace individual buckets with raw bytes
    #[prost(bytes = "vec", tag = "1")]
    pub raw_bucket_data: ::prost::alloc::vec::Vec<u8>,
    #[prost(uint32, tag = "2")]
    pub num_buckets: u32,
    #[prost(uint32, tag = "3")]
    pub processing_time_ms: u32,
    #[prost(bool, tag = "4")]
    pub is_last_chunk: bool,
}
/// Add new message definitions
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllClientPrfKeysRequest {
    #[prost(uint32, tag = "1")]
    pub num_clients: u32,
    #[prost(uint32, tag = "2")]
    pub start_client_index: u32,
}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct GetAllClientPrfKeysResponse {
    #[prost(message, repeated, tag = "1")]
    pub client_keys: ::prost::alloc::vec::Vec<Key>,
    /// For reporting purposes
    #[prost(uint32, tag = "2")]
    pub total_key_bytes: u32,
    /// Indicates if more chunks are needed
    #[prost(uint32, tag = "3")]
    pub remaining_clients: u32,
}
/// Add near the end of the file
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreGenerateTestDataRequest {}
#[allow(clippy::derive_partial_eq_without_eq)]
#[derive(Clone, PartialEq, ::prost::Message)]
pub struct PreGenerateTestDataResponse {
    #[prost(bool, tag = "1")]
    pub success: bool,
}
/// Generated client implementations.
pub mod server1_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Server1 Service
    #[derive(Debug, Clone)]
    pub struct Server1ServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl Server1ServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> Server1ServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> Server1ServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            Server1ServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn queue_write(
            &mut self,
            request: impl tonic::IntoRequest<super::QueueWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueueWriteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server1Service/QueueWrite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server1Service", "QueueWrite"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_write(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchWriteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server1Service/BatchWrite",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server1Service", "BatchWrite"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn batch_init(
            &mut self,
            request: impl tonic::IntoRequest<super::BatchInitRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchInitResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server1Service/BatchInit",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server1Service", "BatchInit"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated client implementations.
pub mod server2_service_client {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    use tonic::codegen::http::Uri;
    /// Server2 Service
    #[derive(Debug, Clone)]
    pub struct Server2ServiceClient<T> {
        inner: tonic::client::Grpc<T>,
    }
    impl Server2ServiceClient<tonic::transport::Channel> {
        /// Attempt to create a new client by connecting to a given endpoint.
        pub async fn connect<D>(dst: D) -> Result<Self, tonic::transport::Error>
        where
            D: TryInto<tonic::transport::Endpoint>,
            D::Error: Into<StdError>,
        {
            let conn = tonic::transport::Endpoint::new(dst)?.connect().await?;
            Ok(Self::new(conn))
        }
    }
    impl<T> Server2ServiceClient<T>
    where
        T: tonic::client::GrpcService<tonic::body::BoxBody>,
        T::Error: Into<StdError>,
        T::ResponseBody: Body<Data = Bytes> + Send + 'static,
        <T::ResponseBody as Body>::Error: Into<StdError> + Send,
    {
        pub fn new(inner: T) -> Self {
            let inner = tonic::client::Grpc::new(inner);
            Self { inner }
        }
        pub fn with_origin(inner: T, origin: Uri) -> Self {
            let inner = tonic::client::Grpc::with_origin(inner, origin);
            Self { inner }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> Server2ServiceClient<InterceptedService<T, F>>
        where
            F: tonic::service::Interceptor,
            T::ResponseBody: Default,
            T: tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
                Response = http::Response<
                    <T as tonic::client::GrpcService<tonic::body::BoxBody>>::ResponseBody,
                >,
            >,
            <T as tonic::codegen::Service<
                http::Request<tonic::body::BoxBody>,
            >>::Error: Into<StdError> + Send + Sync,
        {
            Server2ServiceClient::new(InterceptedService::new(inner, interceptor))
        }
        /// Compress requests with the given encoding.
        ///
        /// This requires the server to support it otherwise it might respond with an
        /// error.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.send_compressed(encoding);
            self
        }
        /// Enable decompressing responses.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.inner = self.inner.accept_compressed(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_decoding_message_size(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.inner = self.inner.max_encoding_message_size(limit);
            self
        }
        pub async fn read(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static("/myco.Server2Service/Read");
            let mut req = request.into_request();
            req.extensions_mut().insert(GrpcMethod::new("myco.Server2Service", "Read"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn write(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::WriteRequest>,
        ) -> std::result::Result<tonic::Response<super::WriteResponse>, tonic::Status> {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/Write",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut().insert(GrpcMethod::new("myco.Server2Service", "Write"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn chunk_write(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::ChunkWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChunkWriteResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/ChunkWrite",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "ChunkWrite"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn get_prf_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::GetPrfKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPrfKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/GetPrfKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "GetPrfKeys"));
            self.inner.unary(req, path, codec).await
        }
        pub async fn read_notifs(
            &mut self,
            request: impl tonic::IntoRequest<super::ReadNotifsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadNotifsResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/ReadNotifs",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "ReadNotifs"));
            self.inner.unary(req, path, codec).await
        }
        /// New methods: separate notification chunk streaming and PRF key addition.
        pub async fn notif_chunk_stream(
            &mut self,
            request: impl tonic::IntoStreamingRequest<Message = super::NotifChunkRequest>,
        ) -> std::result::Result<
            tonic::Response<super::NotifChunkResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/NotifChunkStream",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "NotifChunkStream"));
            self.inner.client_streaming(req, path, codec).await
        }
        pub async fn add_prf_key(
            &mut self,
            request: impl tonic::IntoRequest<super::AddPrfKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddPrfKeyResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/AddPrfKey",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "AddPrfKey"));
            self.inner.unary(req, path, codec).await
        }
        /// New method for getting MegaClient writes
        pub async fn get_mega_client_writes(
            &mut self,
            request: impl tonic::IntoRequest<super::GetMegaClientWritesRequest>,
        ) -> std::result::Result<
            tonic::Response<tonic::codec::Streaming<super::GetMegaClientWritesResponse>>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/GetMegaClientWrites",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "GetMegaClientWrites"));
            self.inner.server_streaming(req, path, codec).await
        }
        /// New method for sending indices
        pub async fn chunk_process_read(
            &mut self,
            request: impl tonic::IntoRequest<super::ChunkProcessReadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChunkProcessReadResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/ChunkProcessRead",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "ChunkProcessRead"));
            self.inner.unary(req, path, codec).await
        }
        /// Replace with bidirectional streaming methods
        pub async fn stream_process_read_indices(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::ChunkProcessReadIndicesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::ChunkProcessReadIndicesResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/StreamProcessReadIndices",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("myco.Server2Service", "StreamProcessReadIndices"),
                );
            self.inner.streaming(req, path, codec).await
        }
        pub async fn stream_process_notif_indices(
            &mut self,
            request: impl tonic::IntoStreamingRequest<
                Message = super::ChunkProcessNotifIndicesRequest,
            >,
        ) -> std::result::Result<
            tonic::Response<
                tonic::codec::Streaming<super::ChunkProcessNotifIndicesResponse>,
            >,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/StreamProcessNotifIndices",
            );
            let mut req = request.into_streaming_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("myco.Server2Service", "StreamProcessNotifIndices"),
                );
            self.inner.streaming(req, path, codec).await
        }
        /// Keep the original methods for backward compatibility
        pub async fn chunk_process_read_indices(
            &mut self,
            request: impl tonic::IntoRequest<super::ChunkProcessReadIndicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChunkProcessReadIndicesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/ChunkProcessReadIndices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("myco.Server2Service", "ChunkProcessReadIndices"),
                );
            self.inner.unary(req, path, codec).await
        }
        pub async fn chunk_process_notif_indices(
            &mut self,
            request: impl tonic::IntoRequest<super::ChunkProcessNotifIndicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChunkProcessNotifIndicesResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/ChunkProcessNotifIndices",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(
                    GrpcMethod::new("myco.Server2Service", "ChunkProcessNotifIndices"),
                );
            self.inner.unary(req, path, codec).await
        }
        /// Add to Server2Service
        pub async fn get_all_client_prf_keys(
            &mut self,
            request: impl tonic::IntoRequest<super::GetAllClientPrfKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAllClientPrfKeysResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/GetAllClientPrfKeys",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "GetAllClientPrfKeys"));
            self.inner.unary(req, path, codec).await
        }
        /// Add to Server2Service
        pub async fn pre_generate_test_data(
            &mut self,
            request: impl tonic::IntoRequest<super::PreGenerateTestDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PreGenerateTestDataResponse>,
            tonic::Status,
        > {
            self.inner
                .ready()
                .await
                .map_err(|e| {
                    tonic::Status::new(
                        tonic::Code::Unknown,
                        format!("Service was not ready: {}", e.into()),
                    )
                })?;
            let codec = tonic::codec::ProstCodec::default();
            let path = http::uri::PathAndQuery::from_static(
                "/myco.Server2Service/PreGenerateTestData",
            );
            let mut req = request.into_request();
            req.extensions_mut()
                .insert(GrpcMethod::new("myco.Server2Service", "PreGenerateTestData"));
            self.inner.unary(req, path, codec).await
        }
    }
}
/// Generated server implementations.
pub mod server1_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with Server1ServiceServer.
    #[async_trait]
    pub trait Server1Service: Send + Sync + 'static {
        async fn queue_write(
            &self,
            request: tonic::Request<super::QueueWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::QueueWriteResponse>,
            tonic::Status,
        >;
        async fn batch_write(
            &self,
            request: tonic::Request<super::BatchWriteRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchWriteResponse>,
            tonic::Status,
        >;
        async fn batch_init(
            &self,
            request: tonic::Request<super::BatchInitRequest>,
        ) -> std::result::Result<
            tonic::Response<super::BatchInitResponse>,
            tonic::Status,
        >;
    }
    /// Server1 Service
    #[derive(Debug)]
    pub struct Server1ServiceServer<T: Server1Service> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: Server1Service> Server1ServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for Server1ServiceServer<T>
    where
        T: Server1Service,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/myco.Server1Service/QueueWrite" => {
                    #[allow(non_camel_case_types)]
                    struct QueueWriteSvc<T: Server1Service>(pub Arc<T>);
                    impl<
                        T: Server1Service,
                    > tonic::server::UnaryService<super::QueueWriteRequest>
                    for QueueWriteSvc<T> {
                        type Response = super::QueueWriteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::QueueWriteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server1Service>::queue_write(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = QueueWriteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server1Service/BatchWrite" => {
                    #[allow(non_camel_case_types)]
                    struct BatchWriteSvc<T: Server1Service>(pub Arc<T>);
                    impl<
                        T: Server1Service,
                    > tonic::server::UnaryService<super::BatchWriteRequest>
                    for BatchWriteSvc<T> {
                        type Response = super::BatchWriteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchWriteRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server1Service>::batch_write(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = BatchWriteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server1Service/BatchInit" => {
                    #[allow(non_camel_case_types)]
                    struct BatchInitSvc<T: Server1Service>(pub Arc<T>);
                    impl<
                        T: Server1Service,
                    > tonic::server::UnaryService<super::BatchInitRequest>
                    for BatchInitSvc<T> {
                        type Response = super::BatchInitResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::BatchInitRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server1Service>::batch_init(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = BatchInitSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Server1Service> Clone for Server1ServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Server1Service> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Server1Service> tonic::server::NamedService for Server1ServiceServer<T> {
        const NAME: &'static str = "myco.Server1Service";
    }
}
/// Generated server implementations.
pub mod server2_service_server {
    #![allow(unused_variables, dead_code, missing_docs, clippy::let_unit_value)]
    use tonic::codegen::*;
    /// Generated trait containing gRPC methods that should be implemented for use with Server2ServiceServer.
    #[async_trait]
    pub trait Server2Service: Send + Sync + 'static {
        async fn read(
            &self,
            request: tonic::Request<super::ReadRequest>,
        ) -> std::result::Result<tonic::Response<super::ReadResponse>, tonic::Status>;
        async fn write(
            &self,
            request: tonic::Request<tonic::Streaming<super::WriteRequest>>,
        ) -> std::result::Result<tonic::Response<super::WriteResponse>, tonic::Status>;
        async fn chunk_write(
            &self,
            request: tonic::Request<tonic::Streaming<super::ChunkWriteRequest>>,
        ) -> std::result::Result<
            tonic::Response<super::ChunkWriteResponse>,
            tonic::Status,
        >;
        async fn get_prf_keys(
            &self,
            request: tonic::Request<super::GetPrfKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetPrfKeysResponse>,
            tonic::Status,
        >;
        async fn read_notifs(
            &self,
            request: tonic::Request<super::ReadNotifsRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ReadNotifsResponse>,
            tonic::Status,
        >;
        /// New methods: separate notification chunk streaming and PRF key addition.
        async fn notif_chunk_stream(
            &self,
            request: tonic::Request<tonic::Streaming<super::NotifChunkRequest>>,
        ) -> std::result::Result<
            tonic::Response<super::NotifChunkResponse>,
            tonic::Status,
        >;
        async fn add_prf_key(
            &self,
            request: tonic::Request<super::AddPrfKeyRequest>,
        ) -> std::result::Result<
            tonic::Response<super::AddPrfKeyResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the GetMegaClientWrites method.
        type GetMegaClientWritesStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::GetMegaClientWritesResponse,
                    tonic::Status,
                >,
            >
            + Send
            + 'static;
        /// New method for getting MegaClient writes
        async fn get_mega_client_writes(
            &self,
            request: tonic::Request<super::GetMegaClientWritesRequest>,
        ) -> std::result::Result<
            tonic::Response<Self::GetMegaClientWritesStream>,
            tonic::Status,
        >;
        /// New method for sending indices
        async fn chunk_process_read(
            &self,
            request: tonic::Request<super::ChunkProcessReadRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChunkProcessReadResponse>,
            tonic::Status,
        >;
        /// Server streaming response type for the StreamProcessReadIndices method.
        type StreamProcessReadIndicesStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::ChunkProcessReadIndicesResponse,
                    tonic::Status,
                >,
            >
            + Send
            + 'static;
        /// Replace with bidirectional streaming methods
        async fn stream_process_read_indices(
            &self,
            request: tonic::Request<
                tonic::Streaming<super::ChunkProcessReadIndicesRequest>,
            >,
        ) -> std::result::Result<
            tonic::Response<Self::StreamProcessReadIndicesStream>,
            tonic::Status,
        >;
        /// Server streaming response type for the StreamProcessNotifIndices method.
        type StreamProcessNotifIndicesStream: tonic::codegen::tokio_stream::Stream<
                Item = std::result::Result<
                    super::ChunkProcessNotifIndicesResponse,
                    tonic::Status,
                >,
            >
            + Send
            + 'static;
        async fn stream_process_notif_indices(
            &self,
            request: tonic::Request<
                tonic::Streaming<super::ChunkProcessNotifIndicesRequest>,
            >,
        ) -> std::result::Result<
            tonic::Response<Self::StreamProcessNotifIndicesStream>,
            tonic::Status,
        >;
        /// Keep the original methods for backward compatibility
        async fn chunk_process_read_indices(
            &self,
            request: tonic::Request<super::ChunkProcessReadIndicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChunkProcessReadIndicesResponse>,
            tonic::Status,
        >;
        async fn chunk_process_notif_indices(
            &self,
            request: tonic::Request<super::ChunkProcessNotifIndicesRequest>,
        ) -> std::result::Result<
            tonic::Response<super::ChunkProcessNotifIndicesResponse>,
            tonic::Status,
        >;
        /// Add to Server2Service
        async fn get_all_client_prf_keys(
            &self,
            request: tonic::Request<super::GetAllClientPrfKeysRequest>,
        ) -> std::result::Result<
            tonic::Response<super::GetAllClientPrfKeysResponse>,
            tonic::Status,
        >;
        /// Add to Server2Service
        async fn pre_generate_test_data(
            &self,
            request: tonic::Request<super::PreGenerateTestDataRequest>,
        ) -> std::result::Result<
            tonic::Response<super::PreGenerateTestDataResponse>,
            tonic::Status,
        >;
    }
    /// Server2 Service
    #[derive(Debug)]
    pub struct Server2ServiceServer<T: Server2Service> {
        inner: _Inner<T>,
        accept_compression_encodings: EnabledCompressionEncodings,
        send_compression_encodings: EnabledCompressionEncodings,
        max_decoding_message_size: Option<usize>,
        max_encoding_message_size: Option<usize>,
    }
    struct _Inner<T>(Arc<T>);
    impl<T: Server2Service> Server2ServiceServer<T> {
        pub fn new(inner: T) -> Self {
            Self::from_arc(Arc::new(inner))
        }
        pub fn from_arc(inner: Arc<T>) -> Self {
            let inner = _Inner(inner);
            Self {
                inner,
                accept_compression_encodings: Default::default(),
                send_compression_encodings: Default::default(),
                max_decoding_message_size: None,
                max_encoding_message_size: None,
            }
        }
        pub fn with_interceptor<F>(
            inner: T,
            interceptor: F,
        ) -> InterceptedService<Self, F>
        where
            F: tonic::service::Interceptor,
        {
            InterceptedService::new(Self::new(inner), interceptor)
        }
        /// Enable decompressing requests with the given encoding.
        #[must_use]
        pub fn accept_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.accept_compression_encodings.enable(encoding);
            self
        }
        /// Compress responses with the given encoding, if the client supports it.
        #[must_use]
        pub fn send_compressed(mut self, encoding: CompressionEncoding) -> Self {
            self.send_compression_encodings.enable(encoding);
            self
        }
        /// Limits the maximum size of a decoded message.
        ///
        /// Default: `4MB`
        #[must_use]
        pub fn max_decoding_message_size(mut self, limit: usize) -> Self {
            self.max_decoding_message_size = Some(limit);
            self
        }
        /// Limits the maximum size of an encoded message.
        ///
        /// Default: `usize::MAX`
        #[must_use]
        pub fn max_encoding_message_size(mut self, limit: usize) -> Self {
            self.max_encoding_message_size = Some(limit);
            self
        }
    }
    impl<T, B> tonic::codegen::Service<http::Request<B>> for Server2ServiceServer<T>
    where
        T: Server2Service,
        B: Body + Send + 'static,
        B::Error: Into<StdError> + Send + 'static,
    {
        type Response = http::Response<tonic::body::BoxBody>;
        type Error = std::convert::Infallible;
        type Future = BoxFuture<Self::Response, Self::Error>;
        fn poll_ready(
            &mut self,
            _cx: &mut Context<'_>,
        ) -> Poll<std::result::Result<(), Self::Error>> {
            Poll::Ready(Ok(()))
        }
        fn call(&mut self, req: http::Request<B>) -> Self::Future {
            let inner = self.inner.clone();
            match req.uri().path() {
                "/myco.Server2Service/Read" => {
                    #[allow(non_camel_case_types)]
                    struct ReadSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::ReadRequest> for ReadSvc<T> {
                        type Response = super::ReadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::read(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ReadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/Write" => {
                    #[allow(non_camel_case_types)]
                    struct WriteSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::ClientStreamingService<super::WriteRequest>
                    for WriteSvc<T> {
                        type Response = super::WriteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::WriteRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::write(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = WriteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/ChunkWrite" => {
                    #[allow(non_camel_case_types)]
                    struct ChunkWriteSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::ClientStreamingService<super::ChunkWriteRequest>
                    for ChunkWriteSvc<T> {
                        type Response = super::ChunkWriteResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::ChunkWriteRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::chunk_write(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ChunkWriteSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/GetPrfKeys" => {
                    #[allow(non_camel_case_types)]
                    struct GetPrfKeysSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::GetPrfKeysRequest>
                    for GetPrfKeysSvc<T> {
                        type Response = super::GetPrfKeysResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetPrfKeysRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::get_prf_keys(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetPrfKeysSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/ReadNotifs" => {
                    #[allow(non_camel_case_types)]
                    struct ReadNotifsSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::ReadNotifsRequest>
                    for ReadNotifsSvc<T> {
                        type Response = super::ReadNotifsResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ReadNotifsRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::read_notifs(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ReadNotifsSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/NotifChunkStream" => {
                    #[allow(non_camel_case_types)]
                    struct NotifChunkStreamSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::ClientStreamingService<super::NotifChunkRequest>
                    for NotifChunkStreamSvc<T> {
                        type Response = super::NotifChunkResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::NotifChunkRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::notif_chunk_stream(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = NotifChunkStreamSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.client_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/AddPrfKey" => {
                    #[allow(non_camel_case_types)]
                    struct AddPrfKeySvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::AddPrfKeyRequest>
                    for AddPrfKeySvc<T> {
                        type Response = super::AddPrfKeyResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::AddPrfKeyRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::add_prf_key(&inner, request).await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = AddPrfKeySvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/GetMegaClientWrites" => {
                    #[allow(non_camel_case_types)]
                    struct GetMegaClientWritesSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::ServerStreamingService<
                        super::GetMegaClientWritesRequest,
                    > for GetMegaClientWritesSvc<T> {
                        type Response = super::GetMegaClientWritesResponse;
                        type ResponseStream = T::GetMegaClientWritesStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetMegaClientWritesRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::get_mega_client_writes(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetMegaClientWritesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.server_streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/ChunkProcessRead" => {
                    #[allow(non_camel_case_types)]
                    struct ChunkProcessReadSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::ChunkProcessReadRequest>
                    for ChunkProcessReadSvc<T> {
                        type Response = super::ChunkProcessReadResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::ChunkProcessReadRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::chunk_process_read(&inner, request)
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ChunkProcessReadSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/StreamProcessReadIndices" => {
                    #[allow(non_camel_case_types)]
                    struct StreamProcessReadIndicesSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::StreamingService<
                        super::ChunkProcessReadIndicesRequest,
                    > for StreamProcessReadIndicesSvc<T> {
                        type Response = super::ChunkProcessReadIndicesResponse;
                        type ResponseStream = T::StreamProcessReadIndicesStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::ChunkProcessReadIndicesRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::stream_process_read_indices(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StreamProcessReadIndicesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/StreamProcessNotifIndices" => {
                    #[allow(non_camel_case_types)]
                    struct StreamProcessNotifIndicesSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::StreamingService<
                        super::ChunkProcessNotifIndicesRequest,
                    > for StreamProcessNotifIndicesSvc<T> {
                        type Response = super::ChunkProcessNotifIndicesResponse;
                        type ResponseStream = T::StreamProcessNotifIndicesStream;
                        type Future = BoxFuture<
                            tonic::Response<Self::ResponseStream>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                tonic::Streaming<super::ChunkProcessNotifIndicesRequest>,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::stream_process_notif_indices(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = StreamProcessNotifIndicesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.streaming(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/ChunkProcessReadIndices" => {
                    #[allow(non_camel_case_types)]
                    struct ChunkProcessReadIndicesSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::ChunkProcessReadIndicesRequest>
                    for ChunkProcessReadIndicesSvc<T> {
                        type Response = super::ChunkProcessReadIndicesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ChunkProcessReadIndicesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::chunk_process_read_indices(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ChunkProcessReadIndicesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/ChunkProcessNotifIndices" => {
                    #[allow(non_camel_case_types)]
                    struct ChunkProcessNotifIndicesSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::ChunkProcessNotifIndicesRequest>
                    for ChunkProcessNotifIndicesSvc<T> {
                        type Response = super::ChunkProcessNotifIndicesResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<
                                super::ChunkProcessNotifIndicesRequest,
                            >,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::chunk_process_notif_indices(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = ChunkProcessNotifIndicesSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/GetAllClientPrfKeys" => {
                    #[allow(non_camel_case_types)]
                    struct GetAllClientPrfKeysSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::GetAllClientPrfKeysRequest>
                    for GetAllClientPrfKeysSvc<T> {
                        type Response = super::GetAllClientPrfKeysResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::GetAllClientPrfKeysRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::get_all_client_prf_keys(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = GetAllClientPrfKeysSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                "/myco.Server2Service/PreGenerateTestData" => {
                    #[allow(non_camel_case_types)]
                    struct PreGenerateTestDataSvc<T: Server2Service>(pub Arc<T>);
                    impl<
                        T: Server2Service,
                    > tonic::server::UnaryService<super::PreGenerateTestDataRequest>
                    for PreGenerateTestDataSvc<T> {
                        type Response = super::PreGenerateTestDataResponse;
                        type Future = BoxFuture<
                            tonic::Response<Self::Response>,
                            tonic::Status,
                        >;
                        fn call(
                            &mut self,
                            request: tonic::Request<super::PreGenerateTestDataRequest>,
                        ) -> Self::Future {
                            let inner = Arc::clone(&self.0);
                            let fut = async move {
                                <T as Server2Service>::pre_generate_test_data(
                                        &inner,
                                        request,
                                    )
                                    .await
                            };
                            Box::pin(fut)
                        }
                    }
                    let accept_compression_encodings = self.accept_compression_encodings;
                    let send_compression_encodings = self.send_compression_encodings;
                    let max_decoding_message_size = self.max_decoding_message_size;
                    let max_encoding_message_size = self.max_encoding_message_size;
                    let inner = self.inner.clone();
                    let fut = async move {
                        let inner = inner.0;
                        let method = PreGenerateTestDataSvc(inner);
                        let codec = tonic::codec::ProstCodec::default();
                        let mut grpc = tonic::server::Grpc::new(codec)
                            .apply_compression_config(
                                accept_compression_encodings,
                                send_compression_encodings,
                            )
                            .apply_max_message_size_config(
                                max_decoding_message_size,
                                max_encoding_message_size,
                            );
                        let res = grpc.unary(method, req).await;
                        Ok(res)
                    };
                    Box::pin(fut)
                }
                _ => {
                    Box::pin(async move {
                        Ok(
                            http::Response::builder()
                                .status(200)
                                .header("grpc-status", "12")
                                .header("content-type", "application/grpc")
                                .body(empty_body())
                                .unwrap(),
                        )
                    })
                }
            }
        }
    }
    impl<T: Server2Service> Clone for Server2ServiceServer<T> {
        fn clone(&self) -> Self {
            let inner = self.inner.clone();
            Self {
                inner,
                accept_compression_encodings: self.accept_compression_encodings,
                send_compression_encodings: self.send_compression_encodings,
                max_decoding_message_size: self.max_decoding_message_size,
                max_encoding_message_size: self.max_encoding_message_size,
            }
        }
    }
    impl<T: Server2Service> Clone for _Inner<T> {
        fn clone(&self) -> Self {
            Self(Arc::clone(&self.0))
        }
    }
    impl<T: std::fmt::Debug> std::fmt::Debug for _Inner<T> {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            write!(f, "{:?}", self.0)
        }
    }
    impl<T: Server2Service> tonic::server::NamedService for Server2ServiceServer<T> {
        const NAME: &'static str = "myco.Server2Service";
    }
}
